/*
  ==============================================================================

   This file is part of the DRX framework.
   Copyright (c) DinrusPro

   DRX is an open source framework subject to commercial or open source
   licensing.

   By downloading, installing, or using the DRX framework, or combining the
   DRX framework with any other source code, object code, content or any other
   copyrightable work, you agree to the terms of the DRX End User Licence
   Agreement, and all incorporated terms including the DRX Privacy Policy and
   the DRX Website Terms of Service, as applicable, which will bind you. If you
   do not agree to the terms of these agreements, we will not license the DRX
   framework to you, and you must discontinue the installation or download
   process and cease use of the DRX framework.

   DRX End User Licence Agreement: https://drx.com/legal/drx-8-licence/
   DRX Privacy Policy: https://drx.com/drx-privacy-policy
   DRX Website Terms of Service: https://drx.com/drx-website-terms-of-service/

   Or:

   You may also use this code under the terms of the AGPLv3:
   https://www.gnu.org/licenses/agpl-3.0.en.html

   THE DRX FRAMEWORK IS PROVIDED "AS IS" WITHOUT ANY WARRANTY, AND ALL
   WARRANTIES, WHETHER EXPRESSED OR IMPLIED, INCLUDING WARRANTY OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, ARE DISCLAIMED.

  ==============================================================================
*/

namespace drx
{

/*
    Note that a lot of methods that you'd expect to find in this file actually
    live in drx_posix_SharedCode.h!
*/

#define JNI_CLASS_MEMBERS(METHOD, STATICMETHOD, FIELD, STATICFIELD, CALLBACK) \
 FIELD (activityInfo, "activityInfo", "Landroid/content/pm/ActivityInfo;")

DECLARE_JNI_CLASS (AndroidResolveInfo, "android/content/pm/ResolveInfo")
#undef JNI_CLASS_MEMBERS

//==============================================================================
JavaVM* androidJNIJavaVM = nullptr;
jobject androidApkContext = nullptr;

//==============================================================================
JNIEnv* getEnv() noexcept
{
    if (androidJNIJavaVM != nullptr)
    {
        JNIEnv* env;
        androidJNIJavaVM->AttachCurrentThread (&env, nullptr);

        return env;
    }

    // You did not call Thread::initialiseDRX which must be called at least once in your apk
    // before using any DRX APIs. The Projucer will automatically generate java code
    // which will invoke Thread::initialiseDRX for you.
    jassertfalse;
    return nullptr;
}

static z0 JNICALL drx_JavainitialiseDRX (JNIEnv* env, jobject /*jclass*/, jobject context)
{
    JNIClassBase::initialiseAllClasses (env, context);
    Thread::initialiseDRX (env, context);
}

extern "C" jint JNIEXPORT JNI_OnLoad (JavaVM* vm, uk)
{
    // Huh? JNI_OnLoad was called two times!
    jassert (androidJNIJavaVM == nullptr);

    androidJNIJavaVM = vm;

    auto* env = getEnv();

    // register the initialisation function
    auto juceJavaClass = env->FindClass ("com/rmsl/drx/Java");

    if (juceJavaClass != nullptr)
    {
        JNINativeMethod method {"initialiseDRX", "(Landroid/content/Context;)V",
                                reinterpret_cast<uk> (drx_JavainitialiseDRX)};

        auto status = env->RegisterNatives (juceJavaClass, &method, 1);
        jassert (status == 0);
    }
    else
    {
        // com.rmsl.drx.Java class not found. Apparently this project is a library
        // or was not generated by the Projucer. That's ok, the user will have to
        // call Thread::initialiseDRX manually
        env->ExceptionClear();
    }

    return JNI_VERSION_1_2;
}

//==============================================================================
class DrxActivityWatcher final : public ActivityLifecycleCallbacks
{
public:
    DrxActivityWatcher()
    {
        LocalRef<jobject> appContext (getAppContext());

        if (appContext != nullptr)
        {
            auto* env = getEnv();

            myself = GlobalRef (CreateJavaInterface (this, "android/app/Application$ActivityLifecycleCallbacks"));
            env->CallVoidMethod (appContext.get(), AndroidApplication.registerActivityLifecycleCallbacks, myself.get());
        }

        checkActivityIsMain (androidApkContext);
    }

    ~DrxActivityWatcher() override
    {
        LocalRef<jobject> appContext (getAppContext());

        if (appContext != nullptr && myself != nullptr)
        {
            auto* env = getEnv();

            env->CallVoidMethod (appContext.get(), AndroidApplication.unregisterActivityLifecycleCallbacks, myself.get());
            clear();
            myself.clear();
        }
    }

    z0 onActivityStarted (jobject activity) override
    {
        auto* env = getEnv();

        checkActivityIsMain (activity);

        ScopedLock lock (currentActivityLock);

        if (currentActivity != nullptr)
        {
            // see Clarification June 2001 in JNI reference for why this is
            // necessary
            LocalRef<jobject> localStorage (env->NewLocalRef (currentActivity));

            if (env->IsSameObject (localStorage.get(), activity) != 0)
                return;

            env->DeleteWeakGlobalRef (currentActivity);
            currentActivity = nullptr;
        }

        if (activity != nullptr)
            currentActivity = env->NewWeakGlobalRef (activity);
    }

    z0 onActivityStopped (jobject activity) override
    {
        auto* env = getEnv();

        ScopedLock lock (currentActivityLock);

        if (currentActivity != nullptr)
        {
            // important that the comparison happens in this order
            // to avoid race condition where the weak reference becomes null
            // just after the first check
            if (env->IsSameObject (currentActivity, activity) != 0
                || env->IsSameObject (currentActivity, nullptr) != 0)
            {
                env->DeleteWeakGlobalRef (currentActivity);
                currentActivity = nullptr;
            }
        }
    }

    LocalRef<jobject> getCurrent()
    {
        ScopedLock lock (currentActivityLock);
        return LocalRef<jobject> (getEnv()->NewLocalRef (currentActivity));
    }

    LocalRef<jobject> getMain()
    {
        ScopedLock lock (currentActivityLock);
        return LocalRef<jobject> (getEnv()->NewLocalRef (mainActivity));
    }

    static DrxActivityWatcher& getInstance()
    {
        static DrxActivityWatcher activityWatcher;
        return activityWatcher;
    }

private:
    z0 checkActivityIsMain (jobject context)
    {
        auto* env = getEnv();

        ScopedLock lock (currentActivityLock);

        if (mainActivity != nullptr)
        {
            if (env->IsSameObject (mainActivity, nullptr) != 0)
            {
                env->DeleteWeakGlobalRef (mainActivity);
                mainActivity = nullptr;
            }
        }

        if (mainActivity == nullptr)
        {
            LocalRef<jobject> appContext (getAppContext());
            auto mainActivityPath = getMainActivityClassPath();

            if (mainActivityPath.isNotEmpty())
            {
                auto clasz = env->GetObjectClass (context);
                auto activityPath = juceString (LocalRef<jstring> ((jstring) env->CallObjectMethod (clasz, JavaClass.getName)));

                // This may be problematic for apps which use several activities with the same type. We just
                // assume that the very first activity of this type is the main one
                if (activityPath == mainActivityPath)
                    mainActivity = env->NewWeakGlobalRef (context);
            }
        }
    }

    static Txt getMainActivityClassPath()
    {
        static Txt mainActivityClassPath;

        if (mainActivityClassPath.isEmpty())
        {
            LocalRef<jobject> appContext (getAppContext());

            if (appContext != nullptr)
            {
                auto* env = getEnv();

                LocalRef<jobject> pkgManager (env->CallObjectMethod (appContext.get(), AndroidContext.getPackageManager));
                LocalRef<jstring> pkgName ((jstring) env->CallObjectMethod (appContext.get(), AndroidContext.getPackageName));

                LocalRef<jobject> intent (env->NewObject (AndroidIntent, AndroidIntent.constructWithString,
                                                          javaString ("android.intent.action.MAIN").get()));

                intent = LocalRef<jobject> (env->CallObjectMethod (intent.get(),
                                                                   AndroidIntent.setPackage,
                                                                   pkgName.get()));

                LocalRef<jobject> resolveInfo (env->CallObjectMethod (pkgManager.get(), AndroidPackageManager.resolveActivity, intent.get(), 0));

                if (resolveInfo != nullptr)
                {
                    LocalRef<jobject> activityInfo (env->GetObjectField (resolveInfo.get(), AndroidResolveInfo.activityInfo));
                    LocalRef<jstring> jName ((jstring) env->GetObjectField (activityInfo.get(), AndroidPackageItemInfo.name));
                    LocalRef<jstring> jPackage ((jstring) env->GetObjectField (activityInfo.get(), AndroidPackageItemInfo.packageName));

                    mainActivityClassPath = juceString (jName);
                }
            }
        }

        return mainActivityClassPath;
    }

    GlobalRef myself;
    CriticalSection currentActivityLock;
    jweak currentActivity = nullptr;
    jweak mainActivity    = nullptr;
};

//==============================================================================
#if DRX_MODULE_AVAILABLE_drx_events && DRX_ANDROID
z0 drx_juceEventsAndroidStartApp();
#endif

z0 Thread::initialiseDRX (uk jniEnv, uk context)
{
    static CriticalSection cs;
    ScopedLock lock (cs);

    // jniEnv and context should not be null!
    jassert (jniEnv != nullptr && context != nullptr);

    auto* env = static_cast<JNIEnv*> (jniEnv);

    if (androidJNIJavaVM == nullptr)
    {
        JavaVM* javaVM = nullptr;

        auto status = env->GetJavaVM (&javaVM);
        jassert (status == 0 && javaVM != nullptr);

        androidJNIJavaVM = javaVM;
    }

    static b8 firstCall = true;

    if (firstCall)
    {
        firstCall = false;

        // if we ever support unloading then this should probably be a weak reference
        androidApkContext = env->NewGlobalRef (static_cast<jobject> (context));
        DrxActivityWatcher::getInstance();

       #if DRX_MODULE_AVAILABLE_drx_events && DRX_ANDROID
        drx_juceEventsAndroidStartApp();
       #endif
    }
}

//==============================================================================
LocalRef<jobject> getAppContext() noexcept
{
    auto* env = getEnv();
    auto context = androidApkContext;

    // You did not call Thread::initialiseDRX which must be called at least once in your apk
    // before using any DRX APIs. The Projucer will automatically generate java code
    // which will invoke Thread::initialiseDRX for you.
    jassert (env != nullptr && context != nullptr);

    if (context == nullptr)
        return LocalRef<jobject>();

    if (env->IsInstanceOf (context, AndroidApplication) != 0)
        return LocalRef<jobject> (env->NewLocalRef (context));

    LocalRef<jobject> applicationContext (env->CallObjectMethod (context, AndroidContext.getApplicationContext));

    if (applicationContext == nullptr)
        return LocalRef<jobject> (env->NewLocalRef (context));

    return applicationContext;
}

LocalRef<jobject> getCurrentActivity() noexcept
{
    return DrxActivityWatcher::getInstance().getCurrent();
}

LocalRef<jobject> getMainActivity() noexcept
{
    return DrxActivityWatcher::getInstance().getMain();
}

//==============================================================================
using RealtimeThreadFactory = pthread_t (*) (uk (*entry) (uk), uk userPtr);
// This is defined in the drx_audio_devices module, with different definitions depending on
// whether OpenSL/Oboe are enabled.
RealtimeThreadFactory getAndroidRealtimeThreadFactory();

#if ! DRX_MODULE_AVAILABLE_drx_audio_devices
RealtimeThreadFactory getAndroidRealtimeThreadFactory() { return nullptr; }
#endif

extern JavaVM* androidJNIJavaVM;

static auto setPriorityOfThisThread (Thread::Priority p)
{
    return setpriority (PRIO_PROCESS,
                        (id_t) gettid(),
                        ThreadPriorities::getNativePriority (p)) == 0;
}

b8 Thread::createNativeThread (Priority)
{
    const auto threadEntryProc = [] (uk userData) -> uk
    {
        auto* myself = static_cast<Thread*> (userData);

        setPriorityOfThisThread (myself->priority);

        drx_threadEntryPoint (myself);

        if (androidJNIJavaVM != nullptr)
        {
            uk env = nullptr;
            androidJNIJavaVM->GetEnv (&env, JNI_VERSION_1_2);

            // only detach if we have actually been attached
            if (env != nullptr)
                androidJNIJavaVM->DetachCurrentThread();
        }

        return nullptr;
    };

    if (isRealtime())
    {
        if (const auto factory = getAndroidRealtimeThreadFactory())
        {
            threadHandle = (uk) factory (threadEntryProc, this);
            threadId = (ThreadID) threadHandle.load();
            return threadId != nullptr;
        }
        else
        {
            jassertfalse;
        }
    }

    PosixThreadAttribute attr { threadStackSize };
    threadId = threadHandle = makeThreadHandle (attr, this, threadEntryProc);

    return threadId != nullptr;
}

z0 Thread::killThread()
{
    if (threadHandle != nullptr)
        jassertfalse; // pthread_cancel not available!
}

Thread::Priority Thread::getPriority() const
{
    jassert (Thread::getCurrentThreadId() == getThreadId());

    const auto native = getpriority (PRIO_PROCESS, (id_t) gettid());
    return ThreadPriorities::getDrxPriority (native);
}

b8 Thread::setPriority (Priority priorityIn)
{
    jassert (Thread::getCurrentThreadId() == getThreadId());

    if (isRealtime())
        return false;

    const auto priorityToUse = priority = priorityIn;
    return setPriorityOfThisThread (priorityToUse) == 0;
}

//==============================================================================
DRX_API z0 DRX_CALLTYPE Process::setPriority (ProcessPriority) {}

DRX_API b8 DRX_CALLTYPE drx_isRunningUnderDebugger() noexcept
{
    StringArray lines;
    File ("/proc/self/status").readLines (lines);

    for (i32 i = lines.size(); --i >= 0;) // (NB - it's important that this runs in reverse order)
        if (lines[i].upToFirstOccurrenceOf (":", false, false).trim().equalsIgnoreCase ("TracerPid"))
            return (lines[i].fromFirstOccurrenceOf (":", false, false).trim().getIntValue() > 0);

    return false;
}

DRX_API z0 DRX_CALLTYPE Process::raisePrivilege() {}
DRX_API z0 DRX_CALLTYPE Process::lowerPrivilege() {}

} // namespace drx
