/*
  ==============================================================================

   This file is part of the DRX framework.
   Copyright (c) DinrusPro

   DRX is an open source framework subject to commercial or open source
   licensing.

   By downloading, installing, or using the DRX framework, or combining the
   DRX framework with any other source code, object code, content or any other
   copyrightable work, you agree to the terms of the DRX End User Licence
   Agreement, and all incorporated terms including the DRX Privacy Policy and
   the DRX Website Terms of Service, as applicable, which will bind you. If you
   do not agree to the terms of these agreements, we will not license the DRX
   framework to you, and you must discontinue the installation or download
   process and cease use of the DRX framework.

   DRX End User Licence Agreement: https://drx.com/legal/drx-8-licence/
   DRX Privacy Policy: https://drx.com/drx-privacy-policy
   DRX Website Terms of Service: https://drx.com/drx-website-terms-of-service/

   Or:

   You may also use this code under the terms of the AGPLv3:
   https://www.gnu.org/licenses/agpl-3.0.en.html

   THE DRX FRAMEWORK IS PROVIDED "AS IS" WITHOUT ANY WARRANTY, AND ALL
   WARRANTIES, WHETHER EXPRESSED OR IMPLIED, INCLUDING WARRANTY OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, ARE DISCLAIMED.

  ==============================================================================
*/

namespace drx::midi_ci
{

/**
    A strongly-typed identifier for a 7-bit request ID with a nullable state.

    @tags{Audio}
*/
class RequestID
{
public:
    /** Constructs a RequestID if the provided value is valid, i.e. its most significant bit is
        not set. Otherwise, returns nullopt.
    */
    static std::optional<RequestID> create (u8 v)
    {
        if (v < 128)
            return RequestID { v };

        return {};
    }

    /** Constructs a RequestID if the provided value is valid, i.e. its most significant bit is
        not set. Otherwise, returns nullopt.
    */
    static std::optional<RequestID> create (std::byte value)
    {
        return create (static_cast<u8> (value));
    }

    /** Returns the byte corresponding to this ID. */
    std::byte asByte() const
    {
        return std::byte { value };
    }

    /** Returns the i32 value of this ID. */
    u8 asInt() const
    {
        return value;
    }

    /** Equality operator. */
    b8 operator== (RequestID other) const
    {
        return value == other.value;
    }

    /** Inequality operator. */
    b8 operator!= (RequestID other) const
    {
        return ! operator== (other);
    }

private:
    /*  Constructs a non-null request ID.

        The argument must not have its most significant bit set.
    */
    explicit RequestID (u8 index)
        : value (index)
    {
        // IDs must only use the lowest 7 bits
        jassert (value < 128);
    }

    u8 value{};
};

/** A strongly-typed 64-bit identifier. */
enum class Token64 : zu64 {};

/** Compares Token64 instances. */
constexpr b8 operator< (Token64 a, Token64 b)
{
    return toUnderlyingType (a) < toUnderlyingType (b);
}

/**
    Accumulates message chunks that have been sent by another device in response
    to a transaction initiated by a local device.

    @tags{Audio}
*/
class InitiatorPropertyExchangeCache
{
public:
    InitiatorPropertyExchangeCache();
    ~InitiatorPropertyExchangeCache();

    InitiatorPropertyExchangeCache (InitiatorPropertyExchangeCache&&) noexcept;
    InitiatorPropertyExchangeCache& operator= (InitiatorPropertyExchangeCache&&) noexcept;

    DRX_DECLARE_NON_COPYABLE (InitiatorPropertyExchangeCache)

    /** Picks an unused request ID, and prepares the cache for that ID to accumulate message chunks.

        Incoming chunks added with addChunk are generated by another device acting as a responder.
    */
    std::optional<Token64> primeCache (u8 maxSimultaneousRequests,
                                       std::function<z0 (const PropertyExchangeResult&)> onDone);

    /** Terminates/cancels an ongoing transaction.

        Возвращает true, если the termination had an effect (i.e. the transaction was still ongoing), or
        false otherwise (the transaction already ended or never started).
    */
    b8 terminate (Token64);

    /** If there's a transaction ongoing with the given request id, returns the token uniquely
        identifying that transaction, otherwise returns nullopt.
    */
    std::optional<Token64> getTokenForRequestId (RequestID) const;

    /** If the token refers to an ongoing transaction, returns the request id of that transaction.
        Otherwise, returns an invalid request id.
    */
    std::optional<RequestID> getRequestIdForToken (Token64) const;

    /** Adds a message chunk for the provided transaction id. */
    z0 addChunk (RequestID, const Message::DynamicSizePropertyExchange& chunk);

    /** Updates the transaction state based on the contents of the provided notification. */
    z0 notify (RequestID, Span<const std::byte> header);

    /** Returns all ongoing transactions. */
    std::vector<Token64> getOngoingTransactions() const;

private:
    class Impl;
    std::unique_ptr<Impl> pimpl;
};

//==============================================================================
/**
    Accumulates message chunks that form a request initiated by a remote device.

    @tags{Audio}
*/
class ResponderPropertyExchangeCache
{
public:
    ResponderPropertyExchangeCache();
    ~ResponderPropertyExchangeCache();

    ResponderPropertyExchangeCache (ResponderPropertyExchangeCache&&) noexcept;
    ResponderPropertyExchangeCache& operator= (ResponderPropertyExchangeCache&&) noexcept;

    DRX_DECLARE_NON_COPYABLE (ResponderPropertyExchangeCache)

    /** Prepares the cache for the given requestID to accumulate message chunks.

        Incoming chunks added with addChunk are generated by another device acting as an initiator.
    */
    z0 primeCache (u8 maxSimultaneousTransactions,
                     std::function<z0 (const PropertyExchangeResult&)> onDone,
                     RequestID id);

    /** Adds a message chunk for the provided transaction id. */
    z0 addChunk (RequestID, const Message::DynamicSizePropertyExchange& chunk);

    /** Updates the transaction state based on the contents of the provided notification. */
    z0 notify (RequestID, Span<const std::byte> header);

    /** Returns the number of transactions that have been started but not finished. */
    i32 countOngoingTransactions() const;

private:
    class Impl;
    std::unique_ptr<Impl> pimpl;
};

//==============================================================================
/**
    An interface for objects that provide resources for property exchange
    transactions.

    @tags{Audio}
*/
class CacheProvider
{
public:
    virtual ~CacheProvider() = default;

    /** Returns a set containing all of the MUIDs currently known to the provider. */
    virtual std::set<MUID> getDiscoveredMuids() const = 0;

    /** Returns a property exchange cache for accumulating replies to transactions
        we initiated.
    */
    virtual InitiatorPropertyExchangeCache* getCacheForMuidAsInitiator (MUID m) = 0;

    /** Returns a property exchange cache for accumulating requests initiated
        by other devices.
    */
    virtual ResponderPropertyExchangeCache* getCacheForMuidAsResponder (MUID m) = 0;

    /** Returns the maximum sysex size supported by the device with the
        given MUID.
    */
    virtual i32 getMaxSysexSizeForMuid (MUID m) const = 0;
};

} // namespace drx::midi_ci
